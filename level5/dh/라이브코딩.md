# 라이브 코딩

## 1. Starting the Interview and Setting the Tone
**Clarifying Readiness:**

Are you ready to start the interview?
Sounds good, let’s go for it.

Confirming Requirements:

Just to confirm, are we using Python 3?
I presume we’ll use [specific language or tool], correct?

## 2. Talking about Your Background
**Brief Background Summary:**

To give you a bit of my background, I graduated in [field], with experience in [specialization].
Since graduation, I’ve been working on [type of projects or roles].

**Educational Background:**

I majored in [major] with a minor in [subject].

## 3. Clarifying the Problem Statement
**Understanding the Problem:**

Could you clarify [specific part of the problem]?
Just to make sure I understand, is this correct: [rephrase problem in your own words]?

Requesting Examples or Diagrams:

It might help if I could see an example structure.
Would it be okay to write out a few cases to understand better?

## 4. Explaining Your Approach
**Describing an Initial Approach:**

The first idea that comes to mind is to use [data structure or method].
My initial approach would involve [briefly describe plan].

Considering Multiple Approaches:

There are two ways to approach this: one is [method], and the other is [alternate method].
We could either use [approach] or consider [another approach].

## 5. Discussing Algorithms and Data Structures
**Talking Through Choices and Complexity:**

Using [data structure or algorithm] makes sense here because it optimizes [specific aspect].
This solution would have a time complexity of [complexity], so it’s efficient for [reason].

**Dynamic Programming Insight:**

There might be a way to use dynamic programming here, though it could be more complex.
The advantage of dynamic programming would be [explain advantage].

## 6. Handling Questions from the Interviewer
**Pausing to Think:**

Good question, let me think that through.
I need a moment to consider how that would affect the solution.

**Explaining Assumptions:**

I’m assuming [specific assumption] for simplicity, is that okay?
For now, let’s assume all values are positive to make it simpler.

## 7. Verifying the Solution
**Testing and Edge Cases:**

Let’s run through a few examples to confirm.
I’m checking for edge cases like [example cases], to ensure robustness.

**Exploring Runtime and Space Complexity:**

In the worst case, this would take [time complexity], but we can optimize by [describe optimization].
I think space complexity could be reduced if we only store [specific elements].

## 8. Handling Code Bugs and Reworking
**Identifying Errors:**

That didn’t work as expected; let me see where it might have gone wrong.
I’ll double-check to see if there’s an off-by-one error here.

**Debugging and Revisions:**

Let’s adjust this part to see if it resolves the issue.
I missed this part, so I’ll update it and try again.

## 9. Closing Remarks and Receiving Feedback
**Wrapping Up and Getting Feedback:**

Thanks for the interview, I’d love to hear any feedback you have.
I appreciate any suggestions for improving my approach or clarity.
